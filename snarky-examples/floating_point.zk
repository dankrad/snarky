// This is an incomplete example of floating point arithmetic. If you want to
// know more about it, ask Mathijs.

module Bignum_bigint = Bigint;

module Float = {
  let base_precision = 16i; // or 8...
  let div_precision = 16i;

  // x / 2^k, x < 2^m, k <= m
  type t =
    { k : int
    , m : int
    , x : field
    };

  type m =
    { x : field
    , r : field
    };

  let take = 
    fun (n, xs) => {
      loop(fun (self, (n, xs)) => {
        if (n = 0i) {
          [] ;
        } else {
          switch(xs) {
            | [] => []
            | x :: xs' => x :: take(n-1i, xs')
          };
        };
      }, (n, xs));
    };

  let low_bits = fun (t) => {
    let bits = List.rev(List.take(base_precision, List.rev(Field.to_bits(~length=t.m, t.x))));
    Field.of_bits(bits);
  };

  let ( * ) = fun (t1, t2) => {
    if (t1.m + t2.m < Field.size_in_bits) {
      { k: t1.k + t2.k
      , m: t1.m + t2.m
      , x: Field.( * )( t1.x , t2.x ) };
    } else {
      /* We could reduce just one but for ease of implementation we
         just reduce both. */
      let x1_trunc = low_bits(t1);
      let x2_trunc = low_bits(t2);
      { k: t1.k + t2.k + t1.m + t2.m - 2 * base_precision
      , m: base_precision + base_precision
      , x: Field.( * )(x1_trunc, x2_trunc)
      };
    };
  };

  let two_to_the : int -> field = fun (n) => {
    Field.of_int(lsl(1, n));
  };

  let low_bits_n = fun (t, n) => {
    let bits = List.rev(List.take(n, List.rev(Field.to_bits(~length=t.m, t.x))));
    Field.of_bits(bits);
  };

  let ( + ) = fun (t1, t2) => {
    if (t1.k >= t2.k) {
      if (t1.m + 1 < Field.size_in_bits) {
        let x2_shift = t1.k - t2.k;
        let x2_trunc = Field.of_int(0);
        if (x2_shift < t2.m) {
          x2_trunc = low_bits_n(t2, t2.m - k);
        };
        { k: t1.k
        , m: t1.m + 1
        , x: Field.( + )( t1.x , x2_trunc ) };
      } else {
        // TODO!
        { k: t1.k
          , m: t1.m + 1
          , x: Field.( + )( t1.x , t2.x ) };
        };
    } else {
      if (t1.m + 1 < Field.size_in_bits) {
        let x1_shift = t2.k - t1.k;
        let x1_trunc = Field.of_int(0);
        if (x1_shift < t1.m) {
          x1_trunc = low_bits_n(t1, t1.m - k);
        };
        { k: t2.k
          , m: t2.m + 1
          , x: Field.( + )( t2.x , x1_trunc ) };
      } else {
        // TODO!
        { k: t1.k
          , m: t1.m + 1
          , x: Field.( + )( t1.x , t2.x ) };
      };
    };
  };


  /*
  * Verify division: a / b  = c 
  * assert on; b * x + r = a * 2^div_precision, where:
  * a = t1.x
  * b = t2.x
  * x = result
  * r = remainder
  * c = a * 2^div_precision 
  */

  let ( / ) = fun (t1, t2) => {
    let div = Prover {
      let a = Bigint.of_field(t1.x);
      let b = Bigint.of_field(t2.x);
        { x : a /% b
        , r : a % b
        };
    };

    assert.r1(t2.x, Field.( + )(x, r), Field.( * )(t1.x, two_to_the(div_precision)));

    { k : t1.k - t2.k
    , m : t1.m + 1
    , x : x * two_to_the(t1.k - t2.k)
    };
  };
};


/*
* Note 1: The bigint lib uses the Zarith lib to compute euclidean division using ediv 
* and erem respectively returning the first and second element of ediv_rem. Point being: 
* there exist cleaner, more efficient, ways to do this.
* https://github.com/janestreet/bignum/blob/master/bigint/src/bigint.ml
* https://dsheets.github.io/codoc/zarith.1.3/z/index.html#/val:ediv_rem
*/