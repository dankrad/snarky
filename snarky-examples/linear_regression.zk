let input_precision = 32i;
let number_of_points = 8i;


let sum = fun( l : List(field)) : field => {
	List.fold_left(+)(0)(l);
	// potential overflow check for large lists
};

let division = fun(a : field, b : field) => {
	let (x, r) = Prover {
      let a = Big_int.big_int_of_string(Field.to_string(a));
      let b = Big_int.big_int_of_string(Field.to_string(b));
      let (x, r) = Big_int.quomod_big_int(a, b);
      (Field.of_string(Big_int.string_of_big_int(x)), Field.of_string(Big_int.string_of_big_int(x)));
    };
    // TODO x and r are correct length
    assert_r1(b, x, Field.( - )(Field.( * )(a, two_to_the(div_precision)), r));
    (x);
};

let mean = fun( l : List(field)) : field => {
	fixed_division()
};

let fixed_division = fun( a : field, b : int) : field => {
};

let two_to_the : int -> field = fun (n) => {
  Big_int.shift_left_big_int(Big_int.unit_big_int, n)
  |> Big_int.string_of_big_int
  |> Field.of_string;
};

let to_bits_signed = fun(length: int, x: field) => {
  let y = Field.( + )(x, two_to_the(length - 1i));
  let bits = Field.to_bits(~length=length, x);
  bits;
};

let take = fun (n, xs) => {
  loop(
    fun (self, (n, xs)) => {
    if (n = 0i) {
      [] ;
    } else {
      switch(xs) {
        | [] => []
        | x :: xstail => x :: self((n - 1i, xstail))
      };
    };
  }, (n, xs));
};

let reduce = fun(length_before, length_after, x) => {
  let bits = List.rev(take(length_after, List.rev(to_bits_signed(length_before, x))));
  Field.of_bits(bits);
};



let main = fun(x1 : field, x2 : field, y1 : field, y2 : field) => {
  let x : List(field) = [x1, x2];
  let y : List(field) = [y1, y2];

  // Compute means
  let x_cap = mean(x); 
  let y_cap = mean(y);

};
