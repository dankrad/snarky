let input_precision = 32i;
let inner_precision = 40i; // Needs to be large enough to hold all the sums
let decimal_point = 16i;
let number_of_points = 8i;


let sum = fun( l : list(field)) : field => {
	List.fold_left(Field.(+))(0)(l);
	// potential overflow check for large lists
};

let two_to_the : int -> field = fun (n) => {
  Big_int.shift_left_big_int(Big_int.unit_big_int, n)
  |> Big_int.string_of_big_int
  |> Field.of_string;
};

let to_bits_signed = fun(length: int, x: field) => {
  let y = Field.( + )(x, two_to_the(length - 1i));
  let bits = Field.to_bits(~length=length, x);
  bits;
};

let division = fun(a : field, b : field) => {
	let (x, r) = Prover {
      let a = Big_int.mult_big_int (Big_int.big_int_of_string(Field.to_string(a)), Big_int.power_int_positive_int(2i, decimal_point));
      let b = Big_int.big_int_of_string(Field.to_string(b));
      let (x, r) = Big_int.quomod_big_int(a, b);
      (Field.of_string(Big_int.string_of_big_int(x)), Field.of_string(Big_int.string_of_big_int(r)));
    };
    
    let bits = to_bits_signed(inner_precision, x);
    Field.Assert.lte(~bit_length=inner_precision, r, b);
    assert_r1(b, x, Field.( - )(Field.( * )(a, two_to_the(decimal_point)), r));

    (x);
};

let mean = fun( l : list(field)) : field => {
	fixed_division();
};

let fixed_division = fun( a : field, b : int) : field => {
  ();
};

let take = fun (n, xs) => {
  loop(
    fun (self, (n, xs)) => {
    if (n = 0i) {
      [] ;
    } else {
      switch(xs) {
        | [] => []
        | x :: xstail => x :: self((n - 1i, xstail))
      };
    };
  }, (n, xs));
};

let reduce = fun(length_before: int, length_after: int, x: field) => {
  let bits = List.rev(take(length_after, List.rev(to_bits_signed(length_before, x))));
  Field.of_bits(bits);
};



let main = fun(x1 : field, x2 : field, y1 : field, y2 : field) => {
  let x : list(field) = [x1, x2];
  let y : list(field) = [y1, y2];

  // Compute means
  let x_cap = mean(x); 
  let y_cap = mean(y);

  let y: field = reduce(32i, 24i, Field.( + )(65537, 256));
  let x = Prover {
  print_string("The reduction is: ");
  print_endline(Field.to_string(y));
  };
  ();
};
