let input_precision = 32i;
let number_of_points = 8i;


let sum = fun( l : List(field)) : field => {
	List.fold_left(0)(+)
};

let division = fun() => {
	
};

let mean = fun() => {
  ();
};

let fixed_division = fun(List(field)) : field => {

let two_to_the : int -> field = fun (n) => {
  Big_int.shift_left_big_int(Big_int.unit_big_int, n)
  |> Big_int.string_of_big_int
  |> Field.of_string;
};

let to_bits_signed = fun(length: int, x: field) => {
  let y = Field.( + )(x, two_to_the(length - 1i));
  let bits = Field.to_bits(~length=length, x);
  bits;
};

let take = fun (n, xs) => {
  loop(
    fun (self, (n, xs)) => {
    if (n = 0i) {
      [] ;
    } else {
      switch(xs) {
        | [] => []
        | x :: xstail => x :: self((n - 1i, xstail))
      };
    };
  }, (n, xs));
};

let reduce = fun(length_before, length_after, x) => {
  let bits = List.rev(take(length_after, List.rev(to_bits_signed(length_before, x))));
  Field.of_bits(bits);
};



let main = fun(x1 : field, x2 : field, y1 : field, y2 : field) => {
  let x : List(field) = [x1, x2];
  let y : List(field) = [y1, y2];

  // Compute means
  let x_cap = mean(x); 
  let y_cap = mean(y);

};
